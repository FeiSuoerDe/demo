
## 一、场景开发流程概览


```
1. 场景创建
└── 2. 基类选择与继承
    └── 3. 接口定义
        └── 4. 仓储实现
            └── 5. 依赖注入配置
                └── 6. 业务逻辑实现
                    └── 7. 资源释放管理


```

## 二、详细开发步骤

### 1. 创建 Godot 场景


- 在 Godot 编辑器中创建新场景（Main Menu）
- 保存为 `MainMenuScreen.tscn`
- 设置主节点类型为对应的基类（如：
[UiScreen](file://D:\GodotProjects\MagicFarmTales\Scripts\UI\Base\UIScreen.cs#L8-L41)
）

### 2. 创建 C# 脚本并继承基类


```csharp
// MainMenuScreen.cs
using Contexts;
using Godot;
using inFras.Nodes.UI.Screens;
using MagicFarmTales.Scripts.UI.Base;
using TO.Nodes.Abstractions.Nodes.UI.Screens;

namespace MagicFarmTales.Scripts.UI.Screens;

public partial class MainMenuScreen : UiScreen, IMainMenuScreen
{
	[Export]
	public Button? StartButton { get; set; }
	
	[Export]
	public Button? SettingsButton { get; set; }
	
	[Export]
	public Button? ExitButton { get; set; }

	public override void _Ready()
	{
		base._Ready();
		NodeScope = NodeContexts.Instance.RegisterNode<IMainMenuScreen, MainMenuScreenRepo>(this);
	}

	protected override void RegisterCallbacks()
	{
		// 注册回调逻辑
	}

	protected override void UnregisterCallbacks()
	{
		// 取消注册回调逻辑
	}
}


```

### 3. 定义接口（Interface）


```csharp
// IMainMenuScreen.cs
using Godot;
using TO.GodotNodes.Abstractions;

namespace TO.Nodes.Abstractions.Nodes.UI.Screens;

public interface IMainMenuScreen : INode
{
	public Button? StartButton { get; protected set; }
	public Button? SettingsButton { get; protected set; }
	public Button? ExitButton { get; protected set; }
}


```

### 4. 实现仓储模式（Repository）


```csharp
// MainMenuScreenRepo.cs
using Godot;
using inFras.Bases;
using TO.Infras.Readers.Abstractions.Nodes.UI.Screens;
using TO.Nodes.Abstractions.Nodes.UI.Screens;

namespace inFras.Nodes.UI.Screens;

public class MainMenuScreenRepo : NodeRepo<IMainMenuScreen>, IMainMenuScreenRepo
{
    public event Action? StartButtonPressed;
    public event Action? SettingsButtonPressed;
    public event Action? ExitButtonPressed;

    public new IMainMenuScreen Node { get; }

    public MainMenuScreenRepo(IMainMenuScreen mainMenuScreen)
    {
        Node = mainMenuScreen;
        Register();
    }

    protected override void ConnectNodeEvents()
    {
        base.ConnectNodeEvents();
        if (Node.StartButton != null) Node.StartButton.Pressed += () => StartButtonPressed?.Invoke();
        if (Node.SettingsButton != null) Node.SettingsButton.Pressed += () => SettingsButtonPressed?.Invoke();
        if (Node.ExitButton != null) Node.ExitButton.Pressed += () => ExitButtonPressed?.Invoke();
    }

    protected override void DisconnectNodeEvents()
    {
        base.DisconnectNodeEvents();
        if (Node.StartButton != null) Node.StartButton.Pressed -= () => StartButtonPressed?.Invoke();
        if (Node.SettingsButton != null) Node.SettingsButton.Pressed -= () => SettingsButtonPressed?.Invoke();
        if (Node.ExitButton != null) Node.ExitButton.Pressed -= () => ExitButtonPressed?.Invoke();
    }
}


```

### 5. 配置依赖注入

#### a. 创建模块配置文件


```csharp
// UIModule.cs
using Apps.UI;
using Autofac;
using TO.Infras.Readers.Abstractions.Nodes.UI.Screens;

namespace Contexts;

public class UIModule : Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterType<MainMenuScreenCommand>()
               .AsSelf()
               .InstancePerMatchingLifetimeScope(typeof(MainMenuScreenRepo));
    }
}


```

#### b. 确保模块已注册


```csharp
// Contexts.cs
using System.Reflection;
using Autofac;

namespace Contexts;

public class Contexts : LazySingleton<Contexts>
{
    private IContainer Container { get; }

    public Contexts()
    {
        var builder = new ContainerBuilder();
        builder.RegisterModule<UIModule>();
        Container = builder.Build();
    }
}


```

### 6. 实现业务逻辑（Command）


```csharp
// MainMenuScreenCommand.cs
using Godot;
using TO.Infras.Readers.Abstractions.Nodes.UI.Screens;

namespace Apps.UI;

public class MainMenuScreenCommand
{
    public MainMenuScreenCommand(IMainMenuScreenRepo repo)
    {
        repo.StartButtonPressed += OnStartButtonPressed;
        repo.SettingsButtonPressed += OnSettingsButtonPressed;
        repo.ExitButtonPressed += OnExitButtonPressed;
    }

    private void OnStartButtonPressed()
    {
        GD.Print("Start button clicked");
        // 实现开始游戏逻辑
    }

    private void OnSettingsButtonPressed()
    {
        GD.Print("Settings button clicked");
        // 实现打开设置逻辑
    }

    private void OnExitButtonPressed()
    {
        GD.Print("Exit button clicked");
        // 实现退出游戏逻辑
    }
}


```

### 7. 资源释放管理


- 所有资源释放由 Autofac 自动管理
- 当节点从场景树移除时，会自动触发以下逻辑：


```csharp
// NodeRepo.cs
private void Unregister()
{
    if (Node == null)
    {
        GD.PrintErr("很奇怪，单例节点取消注册时已经为空了！");
        return;
    }

    Node.TreeExiting -= Unregister;
    Node.Ready -= EmitReady;
    Node.TreeExiting -= EmitTreeExiting;
    DisconnectNodeEvents();
    RepoScope?.Dispose();
    Node = default;
}


```

## 三、开发规范要点

类型 | 命名规范 | 存放位置 | 职责
:----------- | :----------- | :----------- | :-----------
场景 | PascalCase + Screen/Scene后缀 | Scenes目录 | UI结构
主类 | PascalCase + .cs | Scripts/UI/Screens目录 | 节点逻辑
接口 | IPascalCase | TO.Nodes.Abstractions/Nodes/UI/Screens目录 | 定义API
仓储接口 | IPascalCase + Repo.cs | TO.Infras.Readers.Abstractions/Nodes/UI/Screens目录 | 定义业务逻辑接口
仓储实现 | PascalCase + Repo.cs | inFras/Nodes/UI/Screens目录 | 事件绑定
命令 | PascalCase + Command.cs | Apps/UI目录 | 业务逻辑
模块 | PascalCase + Module.cs | Contexts目录 | DI配置


## 四、常见问题处理

### 1. 事件未触发


- 检查按钮是否正确导出 `[Export]`
- 确认 `_Ready()` 方法中是否调用 `base._Ready()`
- 检查仓储中的事件连接逻辑

### 2. 依赖注入失败


- 确认模块中已注册对应命令
- 检查程序集名称是否匹配
- 查看控制台输出是否有错误信息

### 3. 资源泄漏


- 确认所有事件在 `DisconnectNodeEvents()` 中正确解绑
- 使用调试工具检查作用域生命周期

## 五、最佳实践


1. **单一职责原则**：每个类只负责一个功能
2. **接口隔离原则**：按需定义接口，避免冗余依赖
3. **构造函数注入优先**：明确声明依赖关系
4. **作用域限定**：尽量将服务注册限制在需要的作用域内
5. **异步加载优化**：对复杂初始化使用异步加载机制

该规范确保项目保持良好的可维护性、可测试性和可扩展性，同时充分利用Autofac的依赖注入能力。
